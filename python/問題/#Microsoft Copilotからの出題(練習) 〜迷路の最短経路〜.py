# 迷路の解決: 迷路を表現した2次元リストを入力として受け取り、スタートからゴールまでの最短経路を見つけるプログラムを作成してください。
maze = [
    [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1],
    [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
    [1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
    [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
    [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
]
start = (0, 0)  # スタート地点 (行, 列)
end = (19, 19)    # ゴール地点 (行, 列)
trueend = ((end[0]+1, end[1]+1))

stack = [(start[0] + 1, start[1] + 1)]
next_stack = []

new_maze = []

new_maze.append([""]*(len(maze[0])+2))

for i in range(len(maze)):
    new_l = [""]
    for j in range(len(maze[0])):
        if maze[i][j] == 0:
            new_l.append(0)
        else:
            new_l.append("")
    new_l.append("")
    new_maze.append(new_l)

new_maze.append([""]*(len(maze[0])+2))

new_maze[stack[0][1]][stack[0][0]] = 's'

distance = 1
while trueend not in stack:
    for x, y in stack:
        for i in range(4):
            if i == 0: # 上
                if new_maze[y - 1][x] == 0:
                    new_maze[y - 1][x] = distance
                    next_stack.append((x, y - 1))
            if i == 1: # 右
                if new_maze[y][x + 1] == 0:
                    new_maze[y][x + 1] = distance
                    next_stack.append((x + 1, y))
            if i == 2: # 下
                if new_maze[y + 1][x] == 0:
                    new_maze[y + 1][x] = distance
                    next_stack.append((x, y + 1))
            if i == 3: # 左
                if new_maze[y][x - 1] == 0:
                    new_maze[y][x - 1] = distance
                    next_stack.append((x - 1, y))
    stack = next_stack
    next_stack = []
    distance += 1

for i in new_maze:
    print(i)
x, y = trueend
print(f"距離:{new_maze[y][x]}")